// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/QuePlatform/GoSDK/internal/utils"
)

type TypeSeparate string

const (
	TypeSeparateSeparate TypeSeparate = "separate"
)

func (e TypeSeparate) ToPointer() *TypeSeparate {
	return &e
}
func (e *TypeSeparate) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "separate":
		*e = TypeSeparate(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeSeparate: %v", v)
	}
}

type SignerSeparate struct {
	Type TypeSeparate `json:"type"`
	// Reference to credentials for signing.
	Signer SignerRefDto `json:"signer"`
}

func (s SignerSeparate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SignerSeparate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"type", "signer"}); err != nil {
		return err
	}
	return nil
}

func (s *SignerSeparate) GetType() TypeSeparate {
	if s == nil {
		return TypeSeparate("")
	}
	return s.Type
}

func (s *SignerSeparate) GetSigner() SignerRefDto {
	if s == nil {
		return SignerRefDto{}
	}
	return s.Signer
}

type TypeUseMainSigner string

const (
	TypeUseMainSignerUseMainSigner TypeUseMainSigner = "use_main_signer"
)

func (e TypeUseMainSigner) ToPointer() *TypeUseMainSigner {
	return &e
}
func (e *TypeUseMainSigner) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "use_main_signer":
		*e = TypeUseMainSigner(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeUseMainSigner: %v", v)
	}
}

type SignerUseMainSigner struct {
	Type TypeUseMainSigner `json:"type"`
}

func (s SignerUseMainSigner) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SignerUseMainSigner) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (s *SignerUseMainSigner) GetType() TypeUseMainSigner {
	if s == nil {
		return TypeUseMainSigner("")
	}
	return s.Type
}

type SignerType string

const (
	SignerTypeSignerUseMainSigner SignerType = "signer_UseMainSigner"
	SignerTypeSignerSeparate      SignerType = "signer_Separate"
)

type Signer struct {
	SignerUseMainSigner *SignerUseMainSigner `queryParam:"inline" name:"signer"`
	SignerSeparate      *SignerSeparate      `queryParam:"inline" name:"signer"`

	Type SignerType
}

func CreateSignerSignerUseMainSigner(signerUseMainSigner SignerUseMainSigner) Signer {
	typ := SignerTypeSignerUseMainSigner

	return Signer{
		SignerUseMainSigner: &signerUseMainSigner,
		Type:                typ,
	}
}

func CreateSignerSignerSeparate(signerSeparate SignerSeparate) Signer {
	typ := SignerTypeSignerSeparate

	return Signer{
		SignerSeparate: &signerSeparate,
		Type:           typ,
	}
}

func (u *Signer) UnmarshalJSON(data []byte) error {

	var signerSeparate SignerSeparate = SignerSeparate{}
	if err := utils.UnmarshalJSON(data, &signerSeparate, "", true, nil); err == nil {
		u.SignerSeparate = &signerSeparate
		u.Type = SignerTypeSignerSeparate
		return nil
	}

	var signerUseMainSigner SignerUseMainSigner = SignerUseMainSigner{}
	if err := utils.UnmarshalJSON(data, &signerUseMainSigner, "", true, nil); err == nil {
		u.SignerUseMainSigner = &signerUseMainSigner
		u.Type = SignerTypeSignerUseMainSigner
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Signer", string(data))
}

func (u Signer) MarshalJSON() ([]byte, error) {
	if u.SignerUseMainSigner != nil {
		return utils.MarshalJSON(u.SignerUseMainSigner, "", true)
	}

	if u.SignerSeparate != nil {
		return utils.MarshalJSON(u.SignerSeparate, "", true)
	}

	return nil, errors.New("could not marshal union type Signer: all fields are null")
}

// SigningAlg - Algorithm used for the CAWG identity signature.
type SigningAlg string

const (
	SigningAlgEd25519 SigningAlg = "ed25519"
	SigningAlgEs256   SigningAlg = "es256"
	SigningAlgEs384   SigningAlg = "es384"
	SigningAlgPs256   SigningAlg = "ps256"
)

func (e SigningAlg) ToPointer() *SigningAlg {
	return &e
}
func (e *SigningAlg) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ed25519":
		fallthrough
	case "es256":
		fallthrough
	case "es384":
		fallthrough
	case "ps256":
		*e = SigningAlg(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SigningAlg: %v", v)
	}
}

// CawgIdentityDto - Configuration to add a CAWG identity assertion during signing. Presence of this object enables CAWG.
type CawgIdentityDto struct {
	Signer *Signer `json:"signer,omitempty"`
	// Algorithm used for the CAWG identity signature.
	SigningAlg *SigningAlg `default:"ed25519" json:"signing_alg"`
	// Assertion labels that the identity assertion should reference.
	ReferencedAssertions []string `json:"referenced_assertions,omitempty"`
	// Timestamper to use ("digicert" or "custom:<url>").
	Timestamper *string `json:"timestamper,omitempty"`
}

func (c CawgIdentityDto) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CawgIdentityDto) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CawgIdentityDto) GetSigner() *Signer {
	if c == nil {
		return nil
	}
	return c.Signer
}

func (c *CawgIdentityDto) GetSigningAlg() *SigningAlg {
	if c == nil {
		return nil
	}
	return c.SigningAlg
}

func (c *CawgIdentityDto) GetReferencedAssertions() []string {
	if c == nil {
		return nil
	}
	return c.ReferencedAssertions
}

func (c *CawgIdentityDto) GetTimestamper() *string {
	if c == nil {
		return nil
	}
	return c.Timestamper
}
